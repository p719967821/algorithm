写代码时出现的问题，感觉是我写代码时的通病，记录下来，以示警醒，以后不要再错
noj.cn上面检验时左边是表答，右边才是你的输入

我写代码的通病：不注意小的，细的点，导致需要debug很久很久，事倍功半，没有效率，以后写代码时就要把所有情况考虑进去，不要再想着debug反功，
              写时就要注意！！！

1.1001.cpp  不注意题目的范围，想当然的认为测例不会很大，给的数组范围不够大，极端测例通不过，导致错误

2.1042.cpp  -1分析题目错误，凭印象作题，把广搜写成了深搜
            -2在输出时没有加endl，导致电脑没有把暂存器中的结果刷出，还以为自己的深搜写错了，把整个过程debug了一遍，浪费了很多时间

3.1048.cpp  INF使用不对，导致debug了好一会。

4.1006.cpp  -1**广搜都需要退回才能搜到每一种情况**，我就是没有退回所以搜不到另一种情况导致，代码错误
            -2而且要**小心判断if-else要不要加**，这个可能会导致代码走向不同的方向.

5.1243.cpp  根据书本写的，要注意边界条件，写的时候要小心

6.1575.cpp  一遍过，舒服啦～，注意以后写深搜时都要记得回到原来情况（uesd[i]=1;search(9m+1);used[i]=0）

7.1142.cpp  -1深搜如果要返回原来情况，其最终结果是你把要求的值深搜得到了，付给了另一个变量输出，可以得到正确结果，但是要明确在最后你的used数组
            又变成了起始情况，因为写了回到原来情况，所以在一步步的回退过程中used中之前存的数就又变成了0.所以如果一个题要用两次深搜，第二次不
            能借用第一次生成的used。
            -2 测例有问题10000 999过不了

8.1571.cpp  -1 结构体结点在别的函数中改变后，不会引起原函数中原结构体的值改变
            -2 忽略了永远变换不到，输出-1的情况
            -3 学习了map函数的使用 
                 头文件 #include <map>   使用 map <int,int> p;前一个int是关键字，后一个是对应的值
                 其中的函数使用
                  p[i]=4;//直接像数组一样输入，就可以一一对应起来，或者用insert函数
                  检验时就用y=p.count(i)，如果有i，y为1，没有，y为0

9.1541.cpp  在判断时一定要注意，还有一个条件就是change之后值会变的特别大，大于给定的数组值，这个时候就会出现运行错误所以限定条件要加上y<=n
            且if(y <= n && used[y] == 0)时，它的规则实际上是先判断前面部分，在判断后面部分，而不是同时，所以得把y<=n放在前面

10.1025.cpp -1 这个测例感觉也有问题orz。
            -2 map函数对于元素的取值有两种方法，第一种是直接用y=p[关键字]，y就是对应的值，第二种方法就是用at函数y=p.at(关键字)，y就是对应的值.

11.1046.cpp -1 *&*通过这个题总结一下动态归划的两种常见方法*&*
                （1）就是直接两个for循环的那种，其中用来记输出的那个数组就可以认为是备忘录数组（从底向上）
                （2）就是用递归的方法（从上向底，if中填的是起始情况，广搜深搜那种if中填的是最终情况），但是要加一个备忘录数组，使之不用计算第二遍
                
                动态规划什么的还是用第一种方法吧，第二种技术含量过高，（看了夏至学姐的动态规划题，大部分也都是用的第一种方法）如果是可以用循环一边
                倒出来而且可以在自己的能力范围内就多尝试递归吧。            
            -2 这个题用第一种方式做更简单，因为要比较很多次，递归的话情况太复杂。而且此题的关键是
                （1）底算是第一个值，从开头做。
                （2）dp[i]不是只由前一个的dp[i-1]来定，而是从0到i-1中最大的一个来定，所以需要第二层循环   

12.1047.cpp  -1学会了排序从大到小的方法（https://blog.csdn.net/lytwy123/article/details/84503492)

13.1083.cpp   花生米问题，博弈问题（https://www.cnblogs.com/tanky_woo/archive/2010/08/20/1804464.html）
                
14.1003.cpp   快排，一定要非常熟悉

15.1141.cpp   已经找到了最终的结果，但是递归还得一步步回，如果是10*10的全0，深搜会把所有情况都搜一遍，绝对会超时所以用了一个退出break，见60行