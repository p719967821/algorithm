<font size='5' color='blue'>
        总结：</font>
0.由两类题，一种是给一个起点和终点找路的迷宫题，还有一个是按顺序从第一个位置、第二个位置依次找，一直找到最后一个位置

1.
有三种不同情况：1）走迷宫，只有满足条件才搜下一个，没有下一个就直接退回，说明没有路，就不再管了
>   void dfs(int m)
{
    。。。
        if(canplace(m))
        {
            map[m] = 2;
            maxn++;
            dfs(m+1);
            map[m] = 0;
            maxn--;
        }   
    。。。
}

2）判断从某个点出发的某种情况是否成立，即某种状态是否可以，所以从某个点到最后一个点判断每个点是否可以。
>   void dfs(int m)
{
    。。。
        if(canplace(m))
        {
            map[m] = 2;
            maxn++;
            dfs(m+1);
            map[m] = 0;
            maxn--;
        }   
        else
        {
            dfs(m+1);
        }
}

3）判断某种情况是否成立，所以每个点都要两种情况，放与不放，都要考虑。
>   void dfs(int m)
{
    。。。
        if(canplace(m))
        {
            map[m] = 2;
            maxn++;
            dfs(m+1);
            map[m] = 0;
            maxn--;
        }   
        dfs(m+1);
}

2.我的印象中的dfs就是最经典的走迷宫的题，写时有个if-else的框架，但是实际上，这个比下面1312和1241还要难一些

3.对于走迷宫用dfs的模式都是从起点时开始，for循环找四个方向，used[]代表已经走过，找一条路到终点，其中如果有死胡同，不管是否退回，其走的方法都是因为之前都有used[]=1，所以四个方向都走不了，退回到上一步，上一步继续往下一个方向寻找，两者不同就是在死胡同的这个位置留下的一个是已经走过，一个是没有走过（**这个就会影响其他路径的寻找，其他一个路径走到这里本来是可以过的，因为上一个路径找路时改变了这个位置，所以就变的不同，所以不退回不能找出多条路径，只找一次，退回可以多条路径**），还有一点要注意的就是不管是否退回，找到终点后，都还要按原路一步步的退，把所有可走的路都走完（耗时，所以有的只判断是否可走到的题或其他给的时间少会超时的题，此时就要在dfs函数前面多加退回条件，快速退回），**说明不管退回与否，都会把所有的路都找一遍，只是因为前面提到used[]=1会挡路，所以不退回找不全。**

4.对于依次从第一个找到最后一个的题，以1045题的题目例子为例判断不同的情况
1）本来这种题就是应该要不管该位置是否能放都要延续下去的，但是，只有情况一时，就会在第一个不能放的位置停下来，错误。
2）对于情况二且不退回，因为没有退回的步骤，所以不管是if中的还是else中的，dfs都是最后一步，函数一步步回去时直接也退完了，**所以只能寻找到第一个为首的情况，与实际第一个也是可放可不放的情况违背**
3）虽然退回了，但是也停在此步没有更进一步走(因为if完了直接结束，不会到else中)，即任只考虑此处可放的情况，**所以只是把结果传出去以后，把map中的可放的那个几个位置清空了
4）情况三，不退回没有考虑的意义，因为不退回就相当于重复搜了两遍
5）情况三且退回，if中的dfs相当于可放，然后在函数一步步回去时退回且再搜dfs相当于该位置虽然可放但仍不放，此时就把任意位置放与不放的所有情况都考虑到了。
**1312.cpp** **1241.cpp**
    这两个都是最基本的dfs。没有终点，所以没有最终限定条件。目的只是要把每个位置都填满即可，那就只用一个used[]就行了。在写dfs函数时唯一一点要注意的就是不超边界，然后就是递归的搜索每个方向即可。
    **此外除了限定条件的不同外，与走迷宫最大的不同在于不用退回（即在退时不用used[i]再变回0）：**<font color='red'>因为走迷宫是要把所有的路都要找出来，所以每种方法之间不能有干扰，，所以要退回，搜可能去到的位置时，只用一次即可，不用退.</font>
**1010.cpp**
    1.奇偶剪枝，这个真没看懂，以后再研究研究。。。
**1045.cpp**
    这种深搜，就是判断每个位置放和不放两种都要探索，所以定一个if(canplace(m))，一般来说不是只满足条件的dfs(m+1)嘛，但是这个是if内外都要有一个dfs(m+1)，而且外面的那个dfs是if后直接跟dfs，不是再加个else，中写dfs
**1045.cpp**
    1.递归中的return：从被调用函数返回到主调函数中继续执行，并非一遇到return整个递归结束。
    2.如1312中说的一样，这个是只用找一遍，所以used不用退回
**UVA10364.cpp**
    1.这个题相当于第二种类型的3）情况。稍有不同的是还有判断是小于还是相等
    2.其实这个题有很多限制条件，可以再dfs之前就把那些不符合的情况去除掉，节省时间

    
